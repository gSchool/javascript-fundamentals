## Objectives

- Explain what a promise is.
- Explain why a promise is important.
- Send an HTTP request from Node.js with a promise.

## What's a promise?

In Node.js, it's possible to start an I/O operation and then continue with other operations that don't require the I/O to be completed. This approach is called **asynchronous** or **non-blocking** I/O. Any tasks that depend on the I/O operation to be completed still need to wait and are thus blocked. But other operations that don't have a dependency on the I/O operation can continue.

For example, the following `appendContent.js` program appends content to a file using the `fs` core module.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello callback\n';

fs.appendFile(filePath, content, (err) => {
  if (err) {
    console.error(err);
    process.exit(1);
  }

  console.log(content);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

Execute the program.

```shell
node appendContent.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
Hello callback
```

All asynchronous I/O operations that are core to Node.js, like the `fs.appendFile()` method, invoke a callback function when completed. If the operation completes successfully, the callback's first argument is `null`. However, any exceptions generated by the operation, like an insufficient file permissions error, are passed to the callback's first argument.

Remove the user's write permission from the `hello.text` file.

```shell
chmod u-w hello.txt
```

And execute the program again.

```shell
node appendContent.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
{ Error: EACCES: permission denied, open 'hello.txt'
    at Error (native) errno: -13, code: 'EACCES', syscall: 'open', path: 'hello.txt' }
```

Another way to perform an asynchronous I/O operation is with a more sophisticated coding construct called a promise. A **promise** is an object that represents an asynchronous operation that hasn't completed yet, but will in the future. As an object, a promise has the following three possible states.

1. Pending
1. Fulfilled
1. Rejected

**NOTE:** A promise can only be in one state at time.

A newly instantiated promise starts off in the pending state and is given an `executor` callback function. The `executor` callback is invoked right away with two arguments—a `resolve` function and a `reject` function.

The following `appendContentPromise.js` program appends content to a file using the `fs` core module. It performs the exact same asynchronous I/O operation as before, only this time it's wrapped inside the `executor` callback function of a promise.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise.then((content) => {
  console.log(content);
});

promise.catch((err) => {
  console.error(err);
  process.exit(1);
});

console.log('Waiting for the asynchronous I/O operation to complete...');
```

Execute the program.

```shell
node appendContentPromise.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
{ Error: EACCES: permission denied, open 'hello.txt'
    at Error (native) errno: -13, code: 'EACCES', syscall: 'open', path: 'hello.txt' }
```

Add the user's write permission back to the `hello.text` file.

```shell
chmod u+w hello.txt
```

And execute the program again.

```shell
node appendContentPromise.js
```

And you should see something like this.

```text
Waiting for the asynchronous I/O operation to complete...
Hello promise
```

As you can see, the role of the `executor` callback function is to start an asynchronous I/O operation. If the operation generates an error, the callback invokes the `reject()` function, passing along the error. Invoking the `reject()` function permanently changes the state of the promise to rejected.

If the operating doesn't generate an error, the callback invokes the `resolve()` function, passing along the results of the operation. Invoking the `resolve()` function with a value other than another promise permanently changes the state of the promise to fulfilled.

**NOTE:** Believe it or not, a promise can be resolved with the state of another promise. It's a sophisticated technique which you'll practice shortly. Never the less, this is why the function is called `resolve()` and not `fulfill()`.

A promise is **unresolved** while in the pending state. A promised is **resolved** when it's state is changed to either fulfilled or rejected. Once a promise is resolved, it's state can never change.

If a promise is fulfilled, the results of the asynchronous I/O operation are ready. To access them, you use the `then()` method to register a callback. As soon as promise is fulfilled, the registered callbacks will be invoked with the operations results.

On the other hand, if a promise is rejected, the error of the asynchronous I/O operation is ready. To access it, you use the `catch()` method to register a callback. As soon as promise is rejected, the registered callbacks will be invoked with the error.

```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐
│                           │                  │                       │
│                           │───── fulfill ───▶│                       │
│                           │                  │                       │
│                           │                  │                       │
│                           │                  └───────────────────────┘
│          Pending          │
│                           │                  ┌── catch(onRejected) ──┐
│                           │                  │                       │
│                           │                  │                       │
│                           │───── reject ────▶│                       │
│                           │                  │                       │
└───────────────────────────┘                  └───────────────────────┘
```

### Exercise

Turn to a neighbor and explain what a promise is and how it works in your own words. Then, diagram how a promise works.

## Why is a promise important?

The main benefit of a promise is its ability to separate the success handling logic from the error handling logic.

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

```text
┌── new Promise(executor) ──┐                  ┌── then(onFulfilled) ──┐                    ┌────── new Promise() ──────┐
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │───── fulfill ───▶│                       │       return       │                           │
│                           │                  │                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
│                           │                  └───────────────────────┘       throw        │                           │
│          Pending          │                                                               │                           │
│                           │                  ┌── catch(onRejected) ──┐                    │                           │
│                           │                  │                       │────── fulfill ────▶│                           │
│                           │                  │                       │       return       │                           │
│                           │───── reject ────▶│                       │                    │                           │
│                           │                  │                       │────── reject ─────▶│                           │
└───────────────────────────┘                  └───────────────────────┘       throw        └───────────────────────────┘
```

```javascript
'use strict';

const fs = require('fs');
const filePath = 'hello.txt';
const content = 'Hello promise\n';

const promise = new Promise((resolve, reject) => {
  fs.appendFile(filePath, content, (err) => {
    if (err) {
      return reject(err);
    }

    resolve(content);
  });
});

promise
  .then((content) => {
    return content.toUpperCase();
  })
  .then((content) => {
    console.log(content);
  })
  .catch((err) => {
    console.error(err);
    throw err;
  })
  .catch((err) => {
    process.exit(1);
  });

console.log('Waiting for the asynchronous I/O operation to complete...');
```

### Exercise

Turn to a neighbor and explain why a promise is important. Then, diagram how a promise chaining works.

## How do you send an HTTP request from Node.js with a promise?

```shell
mkdir promises
cd promises
```

```shell
npm init
npm install --save request
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });
```

```javascript
'use strict';

const request = require('request');

const getJSON = function(url) {
  const promise = new Promise((resolve, reject) => {
    request.get(url, (err, res, body) => {
      if (err) {
        return reject(err);
      }

      resolve(JSON.parse(body));
    });
  });

  return promise;
};

getJSON('http://www.omdbapi.com/?s=Captain%20America')
  .then((body) => {
    return getJSON(`http://www.omdbapi.com/?i=${body.Search[0].imdbID}`);
  })
  .then((body) => {
    console.log(body);
  })
  .catch((err) => {
    console.error(err);
    process.exit(1);
  });

```

## Assignment

- [Promise Fundamentals](https://github.com/gSchool/wd-promise-fundamentals)

## Resources

- [Introduction to ES6 Promises](http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/)
- [Mozilla Developer Network - Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)
- [Promises Unwrapping - States and Fates](https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md)
- [Promises - In Wicked Detail](http://www.mattgreer.org/articles/promises-in-wicked-detail/)
- [Promises/A+ Standard](https://promisesaplus.com/)
- [Treehouse - Understanding Promises in JavaScript](https://teamtreehouse.com/library/why-promises)
- [We have a problem with promises](http://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html)
- https://medium.com/@isntitvacant/observations-on-promises-2b08a0d0c27#.754mlbfog

## Further Challenges

- https://github.com/gSchool/promise-exercise
- [Github: Promise All](https://github.com/gSchool/promise-all)
- [Github: Promise Challenges](https://github.com/gSchool/promise-challenges)
- [Github: Promise Examples](https://github.com/gSchool/js-promise-examples)
- [Github: Spotify Promise Example](https://github.com/gSchool/spotify-promises-example)
- [Github: Promises Practice](https://github.com/gSchool/post-assessment-promises-practice)
- [Github: Express Error Handling w/ Promises](https://github.com/gSchool/error-handling-in-node-express-promises)


## Videos

### Nested / Chained Promises

**ERRATA:** There's an error at 3:55. The bottom function box should read "f2".

<iframe src="https://player.vimeo.com/video/136801594?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

### `Promise.all`

<iframe src="https://player.vimeo.com/video/136900546?byline=0&portrait=0" width="500" height="281" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>

## Guiding Questions

* What are 3 ways to handle async behavior? What are the advantages and disadvantages of each?
    * Callback
        * Simple to understand
        * Rightward drift
        * Multiple requests simultaneous
    * Deferred
        * Built into jQuery
    * Promise
        * Better for chaining
    * (Calling things in the global scope)
    * (Generators)
* What is "callback hell"?
* What are the methods of promises?
    * .then
    * .catch
* How do you run multiple async requests at the same time?
    * Promise.all
* How do you "promisify" a function?
* Write a promise
* Chain two promises together
* Make a promise reject

## Push Questions

* How do you retry a promise that you rejected?
* How do you retain state from promise to promise?
* What is the second argument to .then?
* What happens if you catch a value and want to keep going?
* Can you chain catches? Thens?

## Slides

[Slides](https://docs.google.com/presentation/d/1ehfrCZ9hpc601dkfXUz7TzrDpSOn_VHuKflOumTasVI/edit?usp=sharing)
